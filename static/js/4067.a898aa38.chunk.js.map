{"version":3,"file":"static/js/4067.a898aa38.chunk.js","mappings":"ySASO,SAASA,EACdC,EACAC,GAEA,MAAO,CACLC,GAAKF,EAAUE,GAAKD,EAAa,GAAMA,EACvCE,GAAKH,EAAUG,GAAKF,EAAa,GAAMA,EAE3C,CAGO,SAASG,EAAkBC,GAChC,MAAMC,EAAQ,CAAEJ,EAAG,EAAGC,EAAG,GAUzB,OARII,EAAAA,EAAAA,cAA4BF,IAC9BC,EAAMJ,EAAIG,EAAMG,cAAc,GAAGC,QACjCH,EAAMH,EAAIE,EAAMG,cAAc,GAAGE,UAEjCJ,EAAMJ,EAAIG,EAAMI,QAChBH,EAAMH,EAAIE,EAAMK,SAGXJ,CACT,CAEO,SAASK,EACdC,GAEA,GAAIA,EAAOC,QACT,MAAO,CACLX,EAAGU,EAAOC,QAAQC,wBAAwBC,MAAQ,EAClDZ,EAAGS,EAAOC,QAAQC,wBAAwBE,OAAS,EAGzD,CAEO,SAASC,EACdC,EACAN,GAEA,GAAIA,EAAOC,QACT,OAAOK,EAAeH,MAAQH,EAAOC,QAAQC,wBAAwBC,KAEzE,CAEO,SAASI,EAAyBC,GACvC,MAAMC,EAAUC,SAASC,iBAAiBH,EAASlB,EAAGkB,EAASjB,GAE/D,GAAIkB,EAAS,CAAC,IAADG,EACX,MAAMC,EAAWJ,EAAgBK,SAAWL,EAC5C,OAAoB,QAApBG,EAAOC,EAAQE,aAAK,IAAAH,EAAAA,EAAIC,EAAQG,EAClC,CAEA,MAAO,EACT,C,uGC3CA,MAAMC,EAAoB,CAAE3B,EAAG,EAAGC,EAAG,GAC/Be,EAAiC,IAClCW,EACHd,MAAO,KACPC,OAAQ,KAEJc,EAA4C,KAC5CC,EAAoB,EACpBC,EAAoB,EAEnB,SAASC,IACd,MAAMrB,GAASsB,EAAAA,EAAAA,QAAsB,OAC9BC,EAAOC,IAAYC,EAAAA,EAAAA,YAAWC,EAAoB,CACvDC,UAAWT,EACXZ,iBACAsB,QAAStB,EACTuB,eAAe,EACfC,WAAYV,EACZW,cAAed,EACfe,0BAA2Bf,EAC3B5B,WAAY8B,IAERc,EAYR,SACET,GAIA,MAAMU,EAAiBzC,IACrB,MAAM0C,GAAkB3C,EAAAA,EAAAA,mBAAkBC,GAC1C+B,EAAS,CAACY,EAAAA,oBAAoBC,YAAaF,GAAiB,EAExDG,EAAcA,KAClBd,EAAS,CAACY,EAAAA,oBAAoBG,WAAW,EAErCC,EAAiB/C,IAErBA,EAAMgD,iBAEN,MAAMN,GAAkB3C,EAAAA,EAAAA,mBAAkBC,GACpCiD,GAAenC,EAAAA,EAAAA,0BAAyB4B,GAE9CX,EAAS,CACPY,EAAAA,oBAAoBO,YACpB,CAAED,eAAclC,SAAU2B,IAC1B,EAIJ,OAAIS,OAAOC,aACF,CACLX,gBACAI,cACAQ,eAAgBR,EAChBE,iBAGK,CAELO,YAAab,EACbc,UAAWV,EACXW,aAAcX,EACdY,YAAaV,EAEbW,aAAcjB,EACdkB,WAAYd,EACZe,YAAab,EAInB,CA3D2Bc,CAAoB9B,GACvC+B,EA4DR,SACE/B,GAGA,MAAO,CACLgC,OAAQA,IAAMhC,EAAS,CAACY,EAAAA,oBAAoBoB,SAC5CC,QAASA,IAAMjC,EAAS,CAACY,EAAAA,oBAAoBqB,UAC7CC,UAAWA,IAAMlC,EAAS,CAACY,EAAAA,oBAAoBsB,YAEnD,CArE4BC,CAAqBnC,GAG/C,OAoEF,SACEA,EACAxB,IAEA4D,EAAAA,EAAAA,YAAU,KACR,MAAMC,EAAWA,KACf,MAAMC,EAAoB,CAAC,EACrBC,GAAWhE,EAAAA,EAAAA,wBAAuBC,GAClC8B,GAAazB,EAAAA,EAAAA,eAAcC,EAAgBN,IAE5CgE,EAAAA,EAAAA,cAAalC,KAChBgC,EAAkBhC,WAAaA,GAE7BiC,IACFD,EAAkBC,SAAWA,GAG3BE,OAAOC,KAAKJ,GAAmBK,OAAS,GAC1C3C,EAAS,CAACY,EAAAA,oBAAoBgC,qBAAsBN,GACtD,EAQF,OAJAD,IAEAjB,OAAOyB,iBAAiB,SAAUR,GAE3B,KACLjB,OAAO0B,oBAAoB,SAAUT,EAAS,CAC/C,GACA,CAAC7D,EAAQwB,GACd,CArGE+C,CAAY/C,EAAUxB,GAEf,IACFuB,EACHvB,SACAiC,mBACAsB,oBAEJ,CA+FA,MAAMiB,EAAiB,GAEvB,SAAS9C,EACPH,EAAwBkD,GAEJ,IADnBC,EAAMC,GAA4BF,EAEnC,OAAQC,GACN,KAAKtC,EAAAA,oBAAoBgC,qBACvB,MAAO,IACF7C,KACAoD,GAGP,KAAKvC,EAAAA,oBAAoBC,YACvB,MAAO,IACFd,EACHM,eAAe,EAGfE,cAAe4C,GAGnB,KAAKvC,EAAAA,oBAAoBO,YAAa,CACpC,MAAMiC,IAAwBD,EAAQjC,aAChCmC,EAAeD,EAAsBD,EAAUzD,EAGrD,OAAKK,EAAMM,cAYJ,IACFN,EAEHI,UAAWT,EACXU,QAAS,IACJL,EAAMK,QAGTtC,EACEiC,EAAMjB,eAAehB,GACpBqF,EAAQnE,SAASlB,EAAIiC,EAAMQ,cAAczC,GAAKiC,EAAMO,WACvDvC,EACEgC,EAAMjB,eAAef,GACpBoF,EAAQnE,SAASjB,EAAIgC,EAAMQ,cAAcxC,GAAKgC,EAAMO,aApBrD8C,GAAuBrD,EAAMI,YAAcT,EACtC,IAAKK,EAAOI,UAAWkD,GAGzBtD,CAmBX,CACA,KAAKa,EAAAA,oBAAoBG,UACvB,MAAO,IACFhB,EAEHM,eAAe,EACfvB,eAAgB,IACXiB,EAAMjB,eAKThB,EAAGiC,EAAMK,QAAQtC,EACjBC,EAAGgC,EAAMK,QAAQrC,IAIvB,KAAK6C,EAAAA,oBAAoBoB,OAAQ,CAAC,IAADsB,EAC/B,MAAMC,EAAgBxD,EAAMlC,WAAamF,EACzC,IAAIQ,EAQJ,OAPIzD,EAAMwC,WACRiB,GAAiB7F,EAAAA,EAAAA,mCACfoC,EAAMwC,SACNgB,IAIG,IACFxD,EACHlC,WAAY0F,EACZ/C,0BACgB,QADS8C,EACvBE,SAAc,IAAAF,EAAAA,EAAIvD,EAAMS,0BAE9B,CACA,KAAKI,EAAAA,oBAAoBqB,QAAS,CAChC,MAAMsB,EAAgBxD,EAAMlC,WAAamF,EACzC,IAAIQ,EAQ8D,IAADC,EAAjE,OAPI1D,EAAMwC,WACRiB,GAAiB7F,EAAAA,EAAAA,mCACfoC,EAAMwC,SACNgB,IAIAA,EAAgB,GAAKxD,EAAMlC,aAAe8B,EACrC,IACFI,EACHlC,WACE0F,EAAgB5D,EACZA,EACA4D,EACN/C,0BACgB,QADSiD,EACvBD,SAAc,IAAAC,EAAAA,EAAI1D,EAAMS,2BAIvBT,CACT,CACA,KAAKa,EAAAA,oBAAoBsB,UACvB,MAAO,IACFnC,EACHlC,WAAY8B,EACZa,0BAA2Bf,EAC3BW,QAAStB,EACTA,eAAgBA,GAGpB,QACE,OAAOiB,EAEb,C,kBC9QO,IAAKa,E,0CAQX,SARWA,GAAAA,EAAAA,EAAmB,+CAAnBA,EAAAA,EAAmB,6BAAnBA,EAAAA,EAAmB,yBAAnBA,EAAAA,EAAmB,6BAAnBA,EAAAA,EAAmB,mBAAnBA,EAAAA,EAAmB,qBAAnBA,EAAAA,EAAmB,yBAQ9B,CARWA,IAAAA,EAAmB,I","sources":["pages/blogs/travel/worldmap/helpers.ts","pages/blogs/travel/worldmap/hooks.ts","pages/blogs/travel/worldmap/types.ts"],"sourcesContent":["import React from \"react\";\r\n\r\nimport {\r\n  T_Coordinates,\r\n  T_SVGEventType,\r\n  T_ViewBoxProps\r\n} from \"pages/blogs/travel/worldmap/types\";\r\nimport { isTouchEvent } from \"shared/helpers/dom\";\r\n\r\nexport function getCompensatoryTranslationForZoom(\r\n  zoomPoint: T_Coordinates,\r\n  zoomFactor: number\r\n): T_Coordinates {\r\n  return {\r\n    x: -(zoomPoint.x * (zoomFactor - 1)) / zoomFactor,\r\n    y: -(zoomPoint.y * (zoomFactor - 1)) / zoomFactor\r\n  };\r\n}\r\n\r\n// This function returns an object with X & Y values from the pointer event\r\nexport function getPointFromEvent(event: T_SVGEventType): T_Coordinates {\r\n  const point = { x: 0, y: 0 };\r\n  // If event is triggered by a touch event, we get the position of the first finger\r\n  if (isTouchEvent<SVGSVGElement>(event)) {\r\n    point.x = event.targetTouches[0].clientX;\r\n    point.y = event.targetTouches[0].clientY;\r\n  } else {\r\n    point.x = event.clientX;\r\n    point.y = event.clientY;\r\n  }\r\n\r\n  return point;\r\n}\r\n\r\nexport function getElementRectMidPoint(\r\n  svgRef: React.RefObject<SVGSVGElement>\r\n): T_Coordinates | void {\r\n  if (svgRef.current) {\r\n    return {\r\n      x: svgRef.current.getBoundingClientRect().width / 2,\r\n      y: svgRef.current.getBoundingClientRect().height / 2\r\n    };\r\n  }\r\n}\r\n\r\nexport function getWidthRatio(\r\n  initialViewBox: T_ViewBoxProps,\r\n  svgRef: React.RefObject<SVGSVGElement>\r\n): number | void {\r\n  if (svgRef.current) {\r\n    return initialViewBox.width / svgRef.current.getBoundingClientRect().width;\r\n  }\r\n}\r\n\r\nexport function getElementTitleFromPoint(position: T_Coordinates): string {\r\n  const element = document.elementFromPoint(position.x, position.y);\r\n\r\n  if (element) {\r\n    const dataObj = (element as any).dataset || element;\r\n    return dataObj.title ?? dataObj.id;\r\n  }\r\n\r\n  return \"\";\r\n}","import { isNullOrVoid } from \"shared/helpers/dataStructure\";\r\nimport {\r\n  getCompensatoryTranslationForZoom,\r\n  getElementRectMidPoint,\r\n  getElementTitleFromPoint,\r\n  getPointFromEvent,\r\n  getWidthRatio\r\n} from \"./helpers\";\r\nimport { useEffect, useReducer, useRef } from \"react\";\r\nimport { T_Nullable } from \"shared/types/generics\";\r\nimport {\r\n  E_MapControlActions,\r\n  T_GeometricInitials,\r\n  T_MapControlAction,\r\n  T_MapControlState,\r\n  T_PointedAt,\r\n  T_SVGEventType,\r\n  T_ViewBoxProps\r\n} from \"./types\";\r\n\r\nconst originCoordinates = { x: 0, y: 0 };\r\nconst initialViewBox: T_ViewBoxProps = {\r\n  ...originCoordinates,\r\n  width: 1010,\r\n  height: 655\r\n};\r\nconst initialPointedAt: T_Nullable<T_PointedAt> = null;\r\nconst initialZoomFactor = 1;\r\nconst initialWidthRatio = 1;\r\n\r\nexport function useMapControls() {\r\n  const svgRef = useRef<SVGSVGElement>(null);\r\n  const [state, dispatch] = useReducer(mapControlsReducer, {\r\n    pointedAt: initialPointedAt,\r\n    initialViewBox,\r\n    viewBox: initialViewBox,\r\n    isPointerDown: false,\r\n    widthRatio: initialWidthRatio,\r\n    pointerOrigin: originCoordinates,\r\n    zoomCompensatoryTranslate: originCoordinates,\r\n    zoomFactor: initialZoomFactor\r\n  });\r\n  const panEventHandlers = usePanEventHandlers(dispatch, svgRef);\r\n  const zoomEventHandlers = useZoomEventHandlers(dispatch, svgRef);\r\n  useGeometry(dispatch, svgRef);\r\n\r\n  return {\r\n    ...state,\r\n    svgRef,\r\n    panEventHandlers,\r\n    zoomEventHandlers\r\n  };\r\n}\r\n\r\nfunction usePanEventHandlers(\r\n  dispatch: React.Dispatch<T_MapControlAction>,\r\n  svgRef: React.RefObject<SVGSVGElement>\r\n) {\r\n  // return useMemo(() => {\r\n  const onPointerDown = (event: T_SVGEventType) => {\r\n    const pointerPosition = getPointFromEvent(event);\r\n    dispatch([E_MapControlActions.pointerDown, pointerPosition]);\r\n  };\r\n  const onPointerUp = () => {\r\n    dispatch([E_MapControlActions.pointerUp]);\r\n  };\r\n  const onPointerMove = (event: T_SVGEventType) => {\r\n    // This prevent user to do a selection on the page\r\n    event.preventDefault();\r\n    // Get the pointer position\r\n    const pointerPosition = getPointFromEvent(event);\r\n    const elementTitle = getElementTitleFromPoint(pointerPosition);\r\n\r\n    dispatch([\r\n      E_MapControlActions.pointerMove,\r\n      { elementTitle, position: pointerPosition }\r\n    ]);\r\n  };\r\n\r\n  // If browser supports pointer events\r\n  if (window.PointerEvent) {\r\n    return {\r\n      onPointerDown,\r\n      onPointerUp,\r\n      onPointerLeave: onPointerUp,\r\n      onPointerMove\r\n    };\r\n  } else {\r\n    return {\r\n      // Add all mouse events listeners fallback\r\n      onMouseDown: onPointerDown,\r\n      onMouseUp: onPointerUp,\r\n      onMouseLeave: onPointerUp,\r\n      onMouseMove: onPointerMove,\r\n      // Add all touch events listeners fallback\r\n      onTouchStart: onPointerDown,\r\n      onTouchEnd: onPointerUp,\r\n      onTouchMove: onPointerMove\r\n    };\r\n  }\r\n  // }, [dispatch]);\r\n}\r\n\r\nfunction useZoomEventHandlers(\r\n  dispatch: React.Dispatch<T_MapControlAction>,\r\n  svgRef: React.RefObject<SVGSVGElement>\r\n) {\r\n  return {\r\n    zoomIn: () => dispatch([E_MapControlActions.zoomIn]),\r\n    zoomOut: () => dispatch([E_MapControlActions.zoomOut]),\r\n    zoomReset: () => dispatch([E_MapControlActions.zoomReset])\r\n  };\r\n}\r\n\r\nfunction useGeometry(\r\n  dispatch: React.Dispatch<T_MapControlAction>,\r\n  svgRef: React.RefObject<SVGSVGElement>\r\n) {\r\n  useEffect(() => {\r\n    const onResize = () => {\r\n      const geometricInitials = {} as T_GeometricInitials;\r\n      const midPoint = getElementRectMidPoint(svgRef);\r\n      const widthRatio = getWidthRatio(initialViewBox, svgRef);\r\n\r\n      if (!isNullOrVoid(widthRatio)) {\r\n        geometricInitials.widthRatio = widthRatio;\r\n      }\r\n      if (midPoint) {\r\n        geometricInitials.midPoint = midPoint;\r\n      }\r\n\r\n      if (Object.keys(geometricInitials).length > 0) {\r\n        dispatch([E_MapControlActions.setGeometricInitials, geometricInitials]);\r\n      }\r\n    };\r\n\r\n    // Calculate once the ratio based on the viewBox width and the SVG width\r\n    onResize();\r\n    // and then listen for any changes\r\n    window.addEventListener(\"resize\", onResize);\r\n\r\n    return () => {\r\n      window.removeEventListener(\"resize\", onResize);\r\n    };\r\n  }, [svgRef, dispatch]);\r\n}\r\n\r\nconst zoomFactorStep = 0.5;\r\n\r\nfunction mapControlsReducer(\r\n  state: T_MapControlState,\r\n  [type, payload]: T_MapControlAction\r\n): T_MapControlState {\r\n  switch (type) {\r\n    case E_MapControlActions.setGeometricInitials: {\r\n      return {\r\n        ...state,\r\n        ...payload\r\n      };\r\n    }\r\n    case E_MapControlActions.pointerDown: {\r\n      return {\r\n        ...state,\r\n        isPointerDown: true,\r\n        // We save the pointer position on click/touchdown\r\n        // so we can get the value once the user starts to drag\r\n        pointerOrigin: payload\r\n      };\r\n    }\r\n    case E_MapControlActions.pointerMove: {\r\n      const isPointedAtRelevant = !!payload.elementTitle;\r\n      const newPointedAt = isPointedAtRelevant ? payload : initialPointedAt;\r\n\r\n      // Only recompute view box positions if the pointer is down\r\n      if (!state.isPointerDown) {\r\n        // Even if pointer is not down, we may still need to update state.pointedAt\r\n        // user moves the pointer. However, we shall update state only if:\r\n        //  - new value of 'pointedAt' corresponds to a relevant element OR\r\n        //  - we need to reset state.pointedAt (when user points to a irrelevant element)\r\n        if (isPointedAtRelevant || state.pointedAt !== initialPointedAt) {\r\n          return { ...state, pointedAt: newPointedAt };\r\n        }\r\n\r\n        return state;\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        // Do not show element title while panning\r\n        pointedAt: initialPointedAt,\r\n        viewBox: {\r\n          ...state.viewBox,\r\n          // We calculate the distance between the pointer origin and the current position\r\n          // The viewBox x & y values must be calculated from the original values and the distances\r\n          x:\r\n            state.initialViewBox.x -\r\n            (payload.position.x - state.pointerOrigin.x) * state.widthRatio,\r\n          y:\r\n            state.initialViewBox.y -\r\n            (payload.position.y - state.pointerOrigin.y) * state.widthRatio\r\n        }\r\n      };\r\n    }\r\n    case E_MapControlActions.pointerUp: {\r\n      return {\r\n        ...state,\r\n        // The pointer is no longer considered as down\r\n        isPointerDown: false,\r\n        initialViewBox: {\r\n          ...state.initialViewBox,\r\n          // We save the viewBox coordinates based on the last pointer offsets\r\n          // This step is important because otherwise we would always calculate\r\n          // the pointer offsets from the original viewBox values and the user\r\n          // will drag the SVG from the starting point every time.\r\n          x: state.viewBox.x,\r\n          y: state.viewBox.y\r\n        }\r\n      };\r\n    }\r\n    case E_MapControlActions.zoomIn: {\r\n      const newZoomFactor = state.zoomFactor + zoomFactorStep;\r\n      let newTranslation;\r\n      if (state.midPoint) {\r\n        newTranslation = getCompensatoryTranslationForZoom(\r\n          state.midPoint,\r\n          newZoomFactor\r\n        );\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        zoomFactor: newZoomFactor,\r\n        zoomCompensatoryTranslate:\r\n          newTranslation ?? state.zoomCompensatoryTranslate\r\n      };\r\n    }\r\n    case E_MapControlActions.zoomOut: {\r\n      const newZoomFactor = state.zoomFactor - zoomFactorStep;\r\n      let newTranslation;\r\n      if (state.midPoint) {\r\n        newTranslation = getCompensatoryTranslationForZoom(\r\n          state.midPoint,\r\n          newZoomFactor\r\n        );\r\n      }\r\n\r\n      if (newZoomFactor > 1 || state.zoomFactor !== initialZoomFactor) {\r\n        return {\r\n          ...state,\r\n          zoomFactor:\r\n            newZoomFactor < initialZoomFactor\r\n              ? initialZoomFactor\r\n              : newZoomFactor,\r\n          zoomCompensatoryTranslate:\r\n            newTranslation ?? state.zoomCompensatoryTranslate\r\n        };\r\n      }\r\n\r\n      return state;\r\n    }\r\n    case E_MapControlActions.zoomReset: {\r\n      return {\r\n        ...state,\r\n        zoomFactor: initialZoomFactor,\r\n        zoomCompensatoryTranslate: originCoordinates,\r\n        viewBox: initialViewBox,\r\n        initialViewBox: initialViewBox\r\n      };\r\n    }\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n","import { T_Nullable } from \"shared/types/generics\";\r\n\r\nexport enum E_MapControlActions {\r\n  setGeometricInitials,\r\n  pointerDown,\r\n  pointerUp,\r\n  pointerMove,\r\n  zoomIn,\r\n  zoomOut,\r\n  zoomReset\r\n}\r\n\r\nexport type T_ViewBoxProps = T_Coordinates & {\r\n  width: number;\r\n  height: number;\r\n};\r\n\r\nexport type T_MapControlState = {\r\n  zoomFactor: number;\r\n  zoomCompensatoryTranslate: T_Coordinates;\r\n  widthRatio: number;\r\n  initialViewBox: T_ViewBoxProps;\r\n  viewBox: T_ViewBoxProps;\r\n  // for move events to check if pointer is down or not\r\n  isPointerDown: boolean;\r\n  // contains the original coordinates when the user start\r\n  // pressing the mouse or touching the screen\r\n  pointerOrigin: T_Coordinates;\r\n  midPoint?: T_Coordinates;\r\n  pointedAt: T_Nullable<T_PointedAt>;\r\n};\r\n\r\nexport type T_Coordinates = { x: number; y: number };\r\nexport type T_GeometricInitials = Partial<{\r\n  midPoint: T_Coordinates;\r\n  widthRatio: number;\r\n}>;\r\n\r\nexport type T_SVGEventType =\r\n  | React.MouseEvent<SVGSVGElement, MouseEvent>\r\n  | React.TouchEvent<SVGSVGElement>;\r\n\r\nexport type T_MapControlAction = [type: E_MapControlActions, payload?: any];\r\n// TODO: Elaborate action types: VS code is able to understand them, but CRA is not\r\n// export type T_MapControlAction =\r\n//   | [\r\n//       type: E_MapControlActions.setGeometricInitials,\r\n//       payload: T_GeometricInitials\r\n//     ]\r\n//   | [type: E_MapControlActions.pointerDown, payload: T_Coordinates]\r\n//   | [type: E_MapControlActions.pointerMove, payload: T_PointedAt]\r\n//   | [type: E_MapControlActions.pointerUp]\r\n//   | [type: E_MapControlActions.zoomIn]\r\n//   | [type: E_MapControlActions.zoomOut]\r\n//   | [type: E_MapControlActions.zoomReset];\r\n\r\nexport type T_PointedAt = {\r\n  elementTitle?: string;\r\n  position: T_Coordinates;\r\n};\r\n"],"names":["getCompensatoryTranslationForZoom","zoomPoint","zoomFactor","x","y","getPointFromEvent","event","point","isTouchEvent","targetTouches","clientX","clientY","getElementRectMidPoint","svgRef","current","getBoundingClientRect","width","height","getWidthRatio","initialViewBox","getElementTitleFromPoint","position","element","document","elementFromPoint","_dataObj$title","dataObj","dataset","title","id","originCoordinates","initialPointedAt","initialZoomFactor","initialWidthRatio","useMapControls","useRef","state","dispatch","useReducer","mapControlsReducer","pointedAt","viewBox","isPointerDown","widthRatio","pointerOrigin","zoomCompensatoryTranslate","panEventHandlers","onPointerDown","pointerPosition","E_MapControlActions","pointerDown","onPointerUp","pointerUp","onPointerMove","preventDefault","elementTitle","pointerMove","window","PointerEvent","onPointerLeave","onMouseDown","onMouseUp","onMouseLeave","onMouseMove","onTouchStart","onTouchEnd","onTouchMove","usePanEventHandlers","zoomEventHandlers","zoomIn","zoomOut","zoomReset","useZoomEventHandlers","useEffect","onResize","geometricInitials","midPoint","isNullOrVoid","Object","keys","length","setGeometricInitials","addEventListener","removeEventListener","useGeometry","zoomFactorStep","_ref","type","payload","isPointedAtRelevant","newPointedAt","_newTranslation","newZoomFactor","newTranslation","_newTranslation2"],"sourceRoot":""}