{"version":3,"file":"static/js/7365.28df00e2.chunk.js","mappings":"iHAAO,IAAWA,E,sEAMjB,SANiBA,GAAAA,EAAY,UAAZA,EAAY,YAAZA,EAAY,UAAZA,EAAY,cAAZA,EAAY,gBAM7B,CANiBA,IAAAA,EAAY,KAiBvB,MAAMC,EAAkBC,GAC7BC,OAAOC,KAAKF,GACTG,QACEC,GACsB,qBAAdJ,EAAOI,IACA,OAAdJ,EAAOI,IACO,KAAdJ,EAAOI,KAEVC,KAAKD,GAAM,GAAGE,mBAAmBF,MAAME,mBAAmBN,EAAOI,QACjEG,KAAK,KAEKC,eAAeC,EAAOC,GAUjC,IAVqC,OACvCC,EAAM,SACNC,EAAQ,OACRZ,EAAM,QACNa,EAAO,KACPC,EAAI,QACJC,GACiBL,EAIbM,EAAMJ,EACNZ,IACFgB,KAA8B,IAAtBA,EAAIC,QAAQ,KAAc,IAAM,KAAOlB,EAAeC,IAGhE,MAAMkB,EAA4B,CAChCL,UACAF,SACAQ,YAAa,cACbC,KAAM,QAEJT,IAAWb,EAAauB,MAAQN,GAAWD,KAC7CI,EAAaJ,KAAOC,GAAWO,KAAKC,UAAUT,IAGhD,IACE,MAAMU,QAAiBC,MAAMT,EAAKE,GAElC,IAAIQ,EAQJ,GALEA,GAJkBF,EAASX,QAAQc,IAAI,iBAAmB,IAG5CC,SAAS,0BACRJ,EAASK,OAEfL,EAGPA,EAASM,QAAU,IACrB,MAAMJ,SAAiBF,EAASO,OAGlC,MAAO,CAAEL,SACX,CAAE,MAAOM,GACP,MAAO,CAAEA,MAAOA,aAAiBC,MAAQD,EAAME,QAAUF,EAC3D,CACF,C","sources":["shared/helpers/request.ts"],"sourcesContent":["export const enum T_HTTPMethod {\r\n  GET = \"GET\",\r\n  POST = \"POST\",\r\n  PUT = \"PUT\",\r\n  PATCH = \"PATCH\",\r\n  DELETE = \"DELETE\"\r\n}\r\n\r\ninterface T_RequestOptions {\r\n  method: T_HTTPMethod;\r\n  endpoint: string;\r\n  params?: { [key: string]: any };\r\n  headers?: HeadersInit;\r\n  body?: any;\r\n  rawBody?: BodyInit | null;\r\n}\r\n\r\nexport const getQueryParams = (params: { [key: string]: string }): string =>\r\n  Object.keys(params)\r\n    .filter(\r\n      (k) =>\r\n        typeof params[k] !== \"undefined\" &&\r\n        params[k] !== null &&\r\n        params[k] !== \"\"\r\n    ) // removes if empty, but accepts \"0\"\r\n    .map((k) => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)\r\n    .join(\"&\");\r\n\r\nexport default async function request<T>({\r\n  method,\r\n  endpoint,\r\n  params,\r\n  headers,\r\n  body,\r\n  rawBody\r\n}: T_RequestOptions): Promise<{\r\n  result?: T;\r\n  error?: unknown;\r\n}> {\r\n  let url = endpoint;\r\n  if (params) {\r\n    url += (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + getQueryParams(params);\r\n  }\r\n\r\n  const fetchOptions: RequestInit = {\r\n    headers,\r\n    method,\r\n    credentials: \"same-origin\",\r\n    mode: \"cors\"\r\n  };\r\n  if (method !== T_HTTPMethod.GET && (rawBody || body)) {\r\n    fetchOptions.body = rawBody || JSON.stringify(body);\r\n  }\r\n\r\n  try {\r\n    const response = await fetch(url, fetchOptions);\r\n    const contentType = response.headers.get(\"Content-Type\") || \"\";\r\n    let result: T;\r\n\r\n    if (contentType.includes(\"application/json\")) {\r\n      result = await response.json();\r\n    } else {\r\n      result = response as unknown as T;\r\n    }\r\n\r\n    if (response.status >= 400) {\r\n      throw result || (await response.text());\r\n    }\r\n\r\n    return { result };\r\n  } catch (error) {\r\n    return { error: error instanceof Error ? error.message : error };\r\n  }\r\n}\r\n"],"names":["T_HTTPMethod","getQueryParams","params","Object","keys","filter","k","map","encodeURIComponent","join","async","request","_ref","method","endpoint","headers","body","rawBody","url","indexOf","fetchOptions","credentials","mode","GET","JSON","stringify","response","fetch","result","get","includes","json","status","text","error","Error","message"],"sourceRoot":""}