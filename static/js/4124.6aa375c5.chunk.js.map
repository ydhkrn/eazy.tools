{"version":3,"file":"static/js/4124.6aa375c5.chunk.js","mappings":"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","sources":["pages/blogs/travel/worldmap/helpers.ts","pages/blogs/travel/worldmap/hooks.ts","pages/blogs/travel/worldmap/types.ts"],"sourcesContent":["import React from \"react\";\n\nimport {\n  T_Coordinates,\n  T_SVGEventType,\n  T_ViewBoxProps\n} from \"pages/blogs/travel/worldmap/types\";\nimport { isTouchEvent } from \"shared/helpers/dom\";\n\nexport function getCompensatoryTranslationForZoom(\n  zoomPoint: T_Coordinates,\n  zoomFactor: number\n): T_Coordinates {\n  return {\n    x: -(zoomPoint.x * (zoomFactor - 1)) / zoomFactor,\n    y: -(zoomPoint.y * (zoomFactor - 1)) / zoomFactor\n  };\n}\n\n// This function returns an object with X & Y values from the pointer event\nexport function getPointFromEvent(event: T_SVGEventType): T_Coordinates {\n  const point = { x: 0, y: 0 };\n  // If event is triggered by a touch event, we get the position of the first finger\n  if (isTouchEvent<SVGSVGElement>(event)) {\n    point.x = event.targetTouches[0].clientX;\n    point.y = event.targetTouches[0].clientY;\n  } else {\n    point.x = event.clientX;\n    point.y = event.clientY;\n  }\n\n  return point;\n}\n\nexport function getElementRectMidPoint(\n  svgRef: React.RefObject<SVGSVGElement>\n): T_Coordinates | void {\n  if (svgRef.current) {\n    return {\n      x: svgRef.current.getBoundingClientRect().width / 2,\n      y: svgRef.current.getBoundingClientRect().height / 2\n    };\n  }\n}\n\nexport function getWidthRatio(\n  initialViewBox: T_ViewBoxProps,\n  svgRef: React.RefObject<SVGSVGElement>\n): number | void {\n  if (svgRef.current) {\n    return initialViewBox.width / svgRef.current.getBoundingClientRect().width;\n  }\n}\n\nexport function getElementTitleFromPoint(position: T_Coordinates): string {\n  const element = document.elementFromPoint(position.x, position.y);\n\n  if (element) {\n    const dataObj = (element as any).dataset || element;\n    return dataObj.title ?? dataObj.id;\n  }\n\n  return \"\";\n}","import { isNullOrVoid } from \"shared/helpers/dataStructure\";\nimport {\n  getCompensatoryTranslationForZoom,\n  getElementRectMidPoint,\n  getElementTitleFromPoint,\n  getPointFromEvent,\n  getWidthRatio\n} from \"./helpers\";\nimport { useEffect, useReducer, useRef } from \"react\";\nimport { T_Nullable } from \"shared/types/generics\";\nimport {\n  E_MapControlActions,\n  T_GeometricInitials,\n  T_MapControlAction,\n  T_MapControlState,\n  T_PointedAt,\n  T_SVGEventType,\n  T_ViewBoxProps\n} from \"./types\";\n\nconst originCoordinates = { x: 0, y: 0 };\nconst initialViewBox: T_ViewBoxProps = {\n  ...originCoordinates,\n  width: 1010,\n  height: 655\n};\nconst initialPointedAt: T_Nullable<T_PointedAt> = null;\nconst initialZoomFactor = 1;\nconst initialWidthRatio = 1;\n\nexport function useMapControls() {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [state, dispatch] = useReducer(mapControlsReducer, {\n    pointedAt: initialPointedAt,\n    initialViewBox,\n    viewBox: initialViewBox,\n    isPointerDown: false,\n    widthRatio: initialWidthRatio,\n    pointerOrigin: originCoordinates,\n    zoomCompensatoryTranslate: originCoordinates,\n    zoomFactor: initialZoomFactor\n  });\n  const panEventHandlers = usePanEventHandlers(dispatch, svgRef);\n  const zoomEventHandlers = useZoomEventHandlers(dispatch, svgRef);\n  useGeometry(dispatch, svgRef);\n\n  return {\n    ...state,\n    svgRef,\n    panEventHandlers,\n    zoomEventHandlers\n  };\n}\n\nfunction usePanEventHandlers(\n  dispatch: React.Dispatch<T_MapControlAction>,\n  svgRef: React.RefObject<SVGSVGElement>\n) {\n  // return useMemo(() => {\n  const onPointerDown = (event: T_SVGEventType) => {\n    const pointerPosition = getPointFromEvent(event);\n    dispatch([E_MapControlActions.pointerDown, pointerPosition]);\n  };\n  const onPointerUp = () => {\n    dispatch([E_MapControlActions.pointerUp]);\n  };\n  const onPointerMove = (event: T_SVGEventType) => {\n    // This prevent user to do a selection on the page\n    event.preventDefault();\n    // Get the pointer position\n    const pointerPosition = getPointFromEvent(event);\n    const elementTitle = getElementTitleFromPoint(pointerPosition);\n\n    dispatch([\n      E_MapControlActions.pointerMove,\n      { elementTitle, position: pointerPosition }\n    ]);\n  };\n\n  // If browser supports pointer events\n  if (window.PointerEvent) {\n    return {\n      onPointerDown,\n      onPointerUp,\n      onPointerLeave: onPointerUp,\n      onPointerMove\n    };\n  } else {\n    return {\n      // Add all mouse events listeners fallback\n      onMouseDown: onPointerDown,\n      onMouseUp: onPointerUp,\n      onMouseLeave: onPointerUp,\n      onMouseMove: onPointerMove,\n      // Add all touch events listeners fallback\n      onTouchStart: onPointerDown,\n      onTouchEnd: onPointerUp,\n      onTouchMove: onPointerMove\n    };\n  }\n  // }, [dispatch]);\n}\n\nfunction useZoomEventHandlers(\n  dispatch: React.Dispatch<T_MapControlAction>,\n  svgRef: React.RefObject<SVGSVGElement>\n) {\n  return {\n    zoomIn: () => dispatch([E_MapControlActions.zoomIn]),\n    zoomOut: () => dispatch([E_MapControlActions.zoomOut]),\n    zoomReset: () => dispatch([E_MapControlActions.zoomReset])\n  };\n}\n\nfunction useGeometry(\n  dispatch: React.Dispatch<T_MapControlAction>,\n  svgRef: React.RefObject<SVGSVGElement>\n) {\n  useEffect(() => {\n    const onResize = () => {\n      const geometricInitials = {} as T_GeometricInitials;\n      const midPoint = getElementRectMidPoint(svgRef);\n      const widthRatio = getWidthRatio(initialViewBox, svgRef);\n\n      if (!isNullOrVoid(widthRatio)) {\n        geometricInitials.widthRatio = widthRatio;\n      }\n      if (midPoint) {\n        geometricInitials.midPoint = midPoint;\n      }\n\n      if (Object.keys(geometricInitials).length > 0) {\n        dispatch([E_MapControlActions.setGeometricInitials, geometricInitials]);\n      }\n    };\n\n    // Calculate once the ratio based on the viewBox width and the SVG width\n    onResize();\n    // and then listen for any changes\n    window.addEventListener(\"resize\", onResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", onResize);\n    };\n  }, [svgRef, dispatch]);\n}\n\nconst zoomFactorStep = 0.5;\n\nfunction mapControlsReducer(\n  state: T_MapControlState,\n  [type, payload]: T_MapControlAction\n): T_MapControlState {\n  switch (type) {\n    case E_MapControlActions.setGeometricInitials: {\n      return {\n        ...state,\n        ...payload\n      };\n    }\n    case E_MapControlActions.pointerDown: {\n      return {\n        ...state,\n        isPointerDown: true,\n        // We save the pointer position on click/touchdown\n        // so we can get the value once the user starts to drag\n        pointerOrigin: payload\n      };\n    }\n    case E_MapControlActions.pointerMove: {\n      const isPointedAtRelevant = !!payload.elementTitle;\n      const newPointedAt = isPointedAtRelevant ? payload : initialPointedAt;\n\n      // Only recompute view box positions if the pointer is down\n      if (!state.isPointerDown) {\n        // Even if pointer is not down, we may still need to update state.pointedAt\n        // user moves the pointer. However, we shall update state only if:\n        //  - new value of 'pointedAt' corresponds to a relevant element OR\n        //  - we need to reset state.pointedAt (when user points to a irrelevant element)\n        if (isPointedAtRelevant || state.pointedAt !== initialPointedAt) {\n          return { ...state, pointedAt: newPointedAt };\n        }\n\n        return state;\n      }\n\n      return {\n        ...state,\n        // Do not show element title while panning\n        pointedAt: initialPointedAt,\n        viewBox: {\n          ...state.viewBox,\n          // We calculate the distance between the pointer origin and the current position\n          // The viewBox x & y values must be calculated from the original values and the distances\n          x:\n            state.initialViewBox.x -\n            (payload.position.x - state.pointerOrigin.x) * state.widthRatio,\n          y:\n            state.initialViewBox.y -\n            (payload.position.y - state.pointerOrigin.y) * state.widthRatio\n        }\n      };\n    }\n    case E_MapControlActions.pointerUp: {\n      return {\n        ...state,\n        // The pointer is no longer considered as down\n        isPointerDown: false,\n        initialViewBox: {\n          ...state.initialViewBox,\n          // We save the viewBox coordinates based on the last pointer offsets\n          // This step is important because otherwise we would always calculate\n          // the pointer offsets from the original viewBox values and the user\n          // will drag the SVG from the starting point every time.\n          x: state.viewBox.x,\n          y: state.viewBox.y\n        }\n      };\n    }\n    case E_MapControlActions.zoomIn: {\n      const newZoomFactor = state.zoomFactor + zoomFactorStep;\n      let newTranslation;\n      if (state.midPoint) {\n        newTranslation = getCompensatoryTranslationForZoom(\n          state.midPoint,\n          newZoomFactor\n        );\n      }\n\n      return {\n        ...state,\n        zoomFactor: newZoomFactor,\n        zoomCompensatoryTranslate:\n          newTranslation ?? state.zoomCompensatoryTranslate\n      };\n    }\n    case E_MapControlActions.zoomOut: {\n      const newZoomFactor = state.zoomFactor - zoomFactorStep;\n      let newTranslation;\n      if (state.midPoint) {\n        newTranslation = getCompensatoryTranslationForZoom(\n          state.midPoint,\n          newZoomFactor\n        );\n      }\n\n      if (newZoomFactor > 1 || state.zoomFactor !== initialZoomFactor) {\n        return {\n          ...state,\n          zoomFactor:\n            newZoomFactor < initialZoomFactor\n              ? initialZoomFactor\n              : newZoomFactor,\n          zoomCompensatoryTranslate:\n            newTranslation ?? state.zoomCompensatoryTranslate\n        };\n      }\n\n      return state;\n    }\n    case E_MapControlActions.zoomReset: {\n      return {\n        ...state,\n        zoomFactor: initialZoomFactor,\n        zoomCompensatoryTranslate: originCoordinates,\n        viewBox: initialViewBox,\n        initialViewBox: initialViewBox\n      };\n    }\n    default:\n      return state;\n  }\n}\n","import { T_Nullable } from \"shared/types/generics\";\n\nexport enum E_MapControlActions {\n  setGeometricInitials,\n  pointerDown,\n  pointerUp,\n  pointerMove,\n  zoomIn,\n  zoomOut,\n  zoomReset\n}\n\nexport type T_ViewBoxProps = T_Coordinates & {\n  width: number;\n  height: number;\n};\n\nexport type T_MapControlState = {\n  zoomFactor: number;\n  zoomCompensatoryTranslate: T_Coordinates;\n  widthRatio: number;\n  initialViewBox: T_ViewBoxProps;\n  viewBox: T_ViewBoxProps;\n  // for move events to check if pointer is down or not\n  isPointerDown: boolean;\n  // contains the original coordinates when the user start\n  // pressing the mouse or touching the screen\n  pointerOrigin: T_Coordinates;\n  midPoint?: T_Coordinates;\n  pointedAt: T_Nullable<T_PointedAt>;\n};\n\nexport type T_Coordinates = { x: number; y: number };\nexport type T_GeometricInitials = Partial<{\n  midPoint: T_Coordinates;\n  widthRatio: number;\n}>;\n\nexport type T_SVGEventType =\n  | React.MouseEvent<SVGSVGElement, MouseEvent>\n  | React.TouchEvent<SVGSVGElement>;\n\nexport type T_MapControlAction = [type: E_MapControlActions, payload?: any];\n// TODO: Elaborate action types: VS code is able to understand them, but CRA is not\n// export type T_MapControlAction =\n//   | [\n//       type: E_MapControlActions.setGeometricInitials,\n//       payload: T_GeometricInitials\n//     ]\n//   | [type: E_MapControlActions.pointerDown, payload: T_Coordinates]\n//   | [type: E_MapControlActions.pointerMove, payload: T_PointedAt]\n//   | [type: E_MapControlActions.pointerUp]\n//   | [type: E_MapControlActions.zoomIn]\n//   | [type: E_MapControlActions.zoomOut]\n//   | [type: E_MapControlActions.zoomReset];\n\nexport type T_PointedAt = {\n  elementTitle?: string;\n  position: T_Coordinates;\n};\n"],"names":["getCompensatoryTranslationForZoom","zoomPoint","zoomFactor","x","y","getPointFromEvent","event","point","isTouchEvent","targetTouches","clientX","clientY","getElementRectMidPoint","svgRef","current","getBoundingClientRect","width","height","getWidthRatio","initialViewBox","getElementTitleFromPoint","position","element","document","elementFromPoint","dataObj","dataset","title","id","originCoordinates","initialPointedAt","useMapControls","useRef","useReducer","mapControlsReducer","pointedAt","viewBox","isPointerDown","widthRatio","pointerOrigin","zoomCompensatoryTranslate","state","dispatch","panEventHandlers","onPointerDown","pointerPosition","E_MapControlActions","onPointerUp","onPointerMove","preventDefault","elementTitle","window","PointerEvent","onPointerLeave","onMouseDown","onMouseUp","onMouseLeave","onMouseMove","onTouchStart","onTouchEnd","onTouchMove","usePanEventHandlers","zoomEventHandlers","zoomIn","zoomOut","zoomReset","useZoomEventHandlers","useEffect","onResize","geometricInitials","midPoint","isNullOrVoid","Object","keys","length","addEventListener","removeEventListener","useGeometry","type","payload","isPointedAtRelevant","newPointedAt","newTranslation","newZoomFactor"],"sourceRoot":""}