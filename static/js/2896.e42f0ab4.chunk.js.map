{"version":3,"file":"static/js/2896.e42f0ab4.chunk.js","mappings":"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","sources":["models/worldMap.ts","pages/Blogs/Travel/Worldmap/hooks.ts","pages/Blogs/Travel/Worldmap/types.ts"],"sourcesContent":["import React from \"react\";\n\nimport {\n  E_MapControlActions,\n  T_Coordinates,\n  T_SVGEventType,\n  T_ViewBoxProps\n} from \"pages/Blogs/Travel/Worldmap/types\";\n\nexport function getCompensatoryTranslationForZoom(\n  zoomPoint: T_Coordinates,\n  zoomFactor: number\n): T_Coordinates {\n  return {\n    x: -(zoomPoint.x * (zoomFactor - 1)) / zoomFactor,\n    y: -(zoomPoint.y * (zoomFactor - 1)) / zoomFactor\n  };\n}\n\n// This function returns an object with X & Y values from the pointer event\nexport function getPointFromEvent(event: T_SVGEventType): T_Coordinates {\n  const point = { x: 0, y: 0 };\n  // If event is triggered by a touch event, we get the position of the first finger\n  if (isTouchEvent(event)) {\n    point.x = event.targetTouches[0].clientX;\n    point.y = event.targetTouches[0].clientY;\n  } else {\n    point.x = event.clientX;\n    point.y = event.clientY;\n  }\n\n  return point;\n}\n\nexport function getElementRectMidPoint(\n  svgRef: React.RefObject<SVGSVGElement>\n): T_Coordinates | void {\n  if (svgRef.current) {\n    return {\n      x: svgRef.current.getBoundingClientRect().width / 2,\n      y: svgRef.current.getBoundingClientRect().height / 2\n    };\n  }\n}\n\nexport function getWidthRatio(\n  initialViewBox: T_ViewBoxProps,\n  svgRef: React.RefObject<SVGSVGElement>\n): number | void {\n  if (svgRef.current) {\n    return initialViewBox.width / svgRef.current.getBoundingClientRect().width;\n  }\n}\n\nexport function getElementTitleFromPoint(position: T_Coordinates): string {\n  const element = document.elementFromPoint(position.x, position.y);\n\n  if (element) {\n    const dataObj = (element as any).dataset || element;\n    return dataObj.title ?? dataObj.id;\n  }\n\n  return \"\";\n}\n\nfunction isTouchEvent(event: any): event is React.TouchEvent<SVGSVGElement> {\n  return !!event?.targetTouches;\n}\n","import { isNullOrVoid } from \"helpers/dataStructure\";\nimport {\n  getCompensatoryTranslationForZoom,\n  getElementRectMidPoint,\n  getElementTitleFromPoint,\n  getPointFromEvent,\n  getWidthRatio\n} from \"models/worldMap\";\nimport { useEffect, useReducer, useRef } from \"react\";\nimport { T_Nullable } from \"types/generic\";\nimport {\n  E_MapControlActions,\n  T_GeometricInitials,\n  T_MapControlAction,\n  T_MapControlState,\n  T_PointedAt,\n  T_SVGEventType,\n  T_ViewBoxProps\n} from \"./types\";\n\nconst originCoordinates = { x: 0, y: 0 };\nconst initialViewBox: T_ViewBoxProps = {\n  ...originCoordinates,\n  width: 1010,\n  height: 655\n};\nconst initialPointedAt: T_Nullable<T_PointedAt> = null;\nconst initialZoomFactor = 1;\nconst initialWidthRatio = 1;\n\nexport function useMapControls() {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [state, dispatch] = useReducer(mapControlsReducer, {\n    pointedAt: initialPointedAt,\n    initialViewBox,\n    viewBox: initialViewBox,\n    isPointerDown: false,\n    widthRatio: initialWidthRatio,\n    pointerOrigin: originCoordinates,\n    zoomCompensatoryTranslate: originCoordinates,\n    zoomFactor: initialZoomFactor\n  });\n  const panEventHandlers = usePanEventHandlers(dispatch, svgRef);\n  const zoomEventHandlers = useZoomEventHandlers(dispatch, svgRef);\n  useGeometry(dispatch, svgRef);\n\n  return {\n    ...state,\n    svgRef,\n    panEventHandlers,\n    zoomEventHandlers\n  };\n}\n\nfunction usePanEventHandlers(\n  dispatch: React.Dispatch<T_MapControlAction>,\n  svgRef: React.RefObject<SVGSVGElement>\n) {\n  // return useMemo(() => {\n  const onPointerDown = (event: T_SVGEventType) => {\n    const pointerPosition = getPointFromEvent(event);\n    dispatch([E_MapControlActions.pointerDown, pointerPosition]);\n  };\n  const onPointerUp = () => {\n    dispatch([E_MapControlActions.pointerUp]);\n  };\n  const onPointerMove = (event: T_SVGEventType) => {\n    // This prevent user to do a selection on the page\n    event.preventDefault();\n    // Get the pointer position\n    const pointerPosition = getPointFromEvent(event);\n    const elementTitle = getElementTitleFromPoint(pointerPosition);\n\n    dispatch([\n      E_MapControlActions.pointerMove,\n      { elementTitle, position: pointerPosition }\n    ]);\n  };\n\n  // If browser supports pointer events\n  if (window.PointerEvent) {\n    return {\n      onPointerDown,\n      onPointerUp,\n      onPointerLeave: onPointerUp,\n      onPointerMove\n    };\n  } else {\n    return {\n      // Add all mouse events listeners fallback\n      onMouseDown: onPointerDown,\n      onMouseUp: onPointerUp,\n      onMouseLeave: onPointerUp,\n      onMouseMove: onPointerMove,\n      // Add all touch events listeners fallback\n      onTouchStart: onPointerDown,\n      onTouchEnd: onPointerUp,\n      onTouchMove: onPointerMove\n    };\n  }\n  // }, [dispatch]);\n}\n\nfunction useZoomEventHandlers(\n  dispatch: React.Dispatch<T_MapControlAction>,\n  svgRef: React.RefObject<SVGSVGElement>\n) {\n  return {\n    zoomIn: () => dispatch([E_MapControlActions.zoomIn]),\n    zoomOut: () => dispatch([E_MapControlActions.zoomOut]),\n    zoomReset: () => dispatch([E_MapControlActions.zoomReset])\n  };\n}\n\nfunction useGeometry(\n  dispatch: React.Dispatch<T_MapControlAction>,\n  svgRef: React.RefObject<SVGSVGElement>\n) {\n  useEffect(() => {\n    const onResize = () => {\n      const geometricInitials = {} as T_GeometricInitials;\n      const midPoint = getElementRectMidPoint(svgRef);\n      const widthRatio = getWidthRatio(initialViewBox, svgRef);\n\n      if (!isNullOrVoid(widthRatio)) {\n        geometricInitials.widthRatio = widthRatio;\n      }\n      if (midPoint) {\n        geometricInitials.midPoint = midPoint;\n      }\n\n      if (Object.keys(geometricInitials).length > 0) {\n        dispatch([E_MapControlActions.setGeometricInitials, geometricInitials]);\n      }\n    };\n\n    // Calculate once the ratio based on the viewBox width and the SVG width\n    onResize();\n    // and then listen for any changes\n    window.addEventListener(\"resize\", onResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", onResize);\n    };\n  }, [svgRef, dispatch]);\n}\n\nconst zoomFactorStep = 0.5;\n\nfunction mapControlsReducer(\n  state: T_MapControlState,\n  [type, payload]: T_MapControlAction\n): T_MapControlState {\n  switch (type) {\n    case E_MapControlActions.setGeometricInitials: {\n      return {\n        ...state,\n        ...payload\n      };\n    }\n    case E_MapControlActions.pointerDown: {\n      return {\n        ...state,\n        isPointerDown: true,\n        // We save the pointer position on click/touchdown\n        // so we can get the value once the user starts to drag\n        pointerOrigin: payload\n      };\n    }\n    case E_MapControlActions.pointerMove: {\n      const isPointedAtRelevant = !!payload.elementTitle;\n      const newPointedAt = isPointedAtRelevant ? payload : initialPointedAt;\n\n      // Only recompute view box positions if the pointer is down\n      if (!state.isPointerDown) {\n        // Even if pointer is not down, we may still need to update state.pointedAt\n        // user moves the pointer. However, we shall update state only if:\n        //  - new value of 'pointedAt' corresponds to a relevant element OR\n        //  - we need to reset state.pointedAt (when user points to a irrelevant element)\n        if (isPointedAtRelevant || state.pointedAt !== initialPointedAt) {\n          return { ...state, pointedAt: newPointedAt };\n        }\n\n        return state;\n      }\n\n      return {\n        ...state,\n        // Do not show element title while panning\n        pointedAt: initialPointedAt,\n        viewBox: {\n          ...state.viewBox,\n          // We calculate the distance between the pointer origin and the current position\n          // The viewBox x & y values must be calculated from the original values and the distances\n          x:\n            state.initialViewBox.x -\n            (payload.position.x - state.pointerOrigin.x) * state.widthRatio,\n          y:\n            state.initialViewBox.y -\n            (payload.position.y - state.pointerOrigin.y) * state.widthRatio\n        }\n      };\n    }\n    case E_MapControlActions.pointerUp: {\n      return {\n        ...state,\n        // The pointer is no longer considered as down\n        isPointerDown: false,\n        initialViewBox: {\n          ...state.initialViewBox,\n          // We save the viewBox coordinates based on the last pointer offsets\n          // This step is important because otherwise we would always calculate\n          // the pointer offsets from the original viewBox values and the user\n          // will drag the SVG from the starting point every time.\n          x: state.viewBox.x,\n          y: state.viewBox.y\n        }\n      };\n    }\n    case E_MapControlActions.zoomIn: {\n      const newZoomFactor = state.zoomFactor + zoomFactorStep;\n      let newTranslation;\n      if (state.midPoint) {\n        newTranslation = getCompensatoryTranslationForZoom(\n          state.midPoint,\n          newZoomFactor\n        );\n      }\n\n      return {\n        ...state,\n        zoomFactor: newZoomFactor,\n        zoomCompensatoryTranslate:\n          newTranslation ?? state.zoomCompensatoryTranslate\n      };\n    }\n    case E_MapControlActions.zoomOut: {\n      const newZoomFactor = state.zoomFactor - zoomFactorStep;\n      let newTranslation;\n      if (state.midPoint) {\n        newTranslation = getCompensatoryTranslationForZoom(\n          state.midPoint,\n          newZoomFactor\n        );\n      }\n\n      if (newZoomFactor > 1 || state.zoomFactor !== initialZoomFactor) {\n        return {\n          ...state,\n          zoomFactor:\n            newZoomFactor < initialZoomFactor\n              ? initialZoomFactor\n              : newZoomFactor,\n          zoomCompensatoryTranslate:\n            newTranslation ?? state.zoomCompensatoryTranslate\n        };\n      }\n\n      return state;\n    }\n    case E_MapControlActions.zoomReset: {\n      return {\n        ...state,\n        zoomFactor: initialZoomFactor,\n        zoomCompensatoryTranslate: originCoordinates,\n        viewBox: initialViewBox,\n        initialViewBox: initialViewBox\n      };\n    }\n    default:\n      return state;\n  }\n}\n","import { T_Nullable } from \"types/generic\";\n\nexport enum E_MapControlActions {\n  setGeometricInitials,\n  pointerDown,\n  pointerUp,\n  pointerMove,\n  zoomIn,\n  zoomOut,\n  zoomReset\n}\n\nexport type T_ViewBoxProps = T_Coordinates & {\n  width: number;\n  height: number;\n};\n\nexport type T_MapControlState = {\n  zoomFactor: number;\n  zoomCompensatoryTranslate: T_Coordinates;\n  widthRatio: number;\n  initialViewBox: T_ViewBoxProps;\n  viewBox: T_ViewBoxProps;\n  // for move events to check if pointer is down or not\n  isPointerDown: boolean;\n  // contains the original coordinates when the user start\n  // pressing the mouse or touching the screen\n  pointerOrigin: T_Coordinates;\n  midPoint?: T_Coordinates;\n  pointedAt: T_Nullable<T_PointedAt>;\n};\n\nexport type T_Coordinates = { x: number; y: number };\nexport type T_GeometricInitials = Partial<{\n  midPoint: T_Coordinates;\n  widthRatio: number;\n}>;\n\nexport type T_SVGEventType =\n  | React.MouseEvent<SVGSVGElement, MouseEvent>\n  | React.TouchEvent<SVGSVGElement>;\n\nexport type T_MapControlAction = [type: E_MapControlActions, payload?: any];\n// TODO: Elaborate action types: VS code is able to understand them, but CRA is not\n// export type T_MapControlAction =\n//   | [\n//       type: E_MapControlActions.setGeometricInitials,\n//       payload: T_GeometricInitials\n//     ]\n//   | [type: E_MapControlActions.pointerDown, payload: T_Coordinates]\n//   | [type: E_MapControlActions.pointerMove, payload: T_PointedAt]\n//   | [type: E_MapControlActions.pointerUp]\n//   | [type: E_MapControlActions.zoomIn]\n//   | [type: E_MapControlActions.zoomOut]\n//   | [type: E_MapControlActions.zoomReset];\n\nexport type T_PointedAt = {\n  elementTitle?: string;\n  position: T_Coordinates;\n};\n"],"names":["getCompensatoryTranslationForZoom","zoomPoint","zoomFactor","x","y","getPointFromEvent","event","point","targetTouches","isTouchEvent","clientX","clientY","getElementRectMidPoint","svgRef","current","getBoundingClientRect","width","height","getWidthRatio","initialViewBox","getElementTitleFromPoint","position","element","document","elementFromPoint","dataObj","dataset","title","id","originCoordinates","initialPointedAt","useMapControls","useRef","useReducer","mapControlsReducer","pointedAt","viewBox","isPointerDown","widthRatio","pointerOrigin","zoomCompensatoryTranslate","state","dispatch","panEventHandlers","onPointerDown","pointerPosition","E_MapControlActions","onPointerUp","onPointerMove","preventDefault","elementTitle","window","PointerEvent","onPointerLeave","onMouseDown","onMouseUp","onMouseLeave","onMouseMove","onTouchStart","onTouchEnd","onTouchMove","usePanEventHandlers","zoomEventHandlers","zoomIn","zoomOut","zoomReset","useZoomEventHandlers","useEffect","onResize","geometricInitials","midPoint","isNullOrVoid","Object","keys","length","addEventListener","removeEventListener","useGeometry","type","payload","isPointedAtRelevant","newPointedAt","newTranslation","newZoomFactor"],"sourceRoot":""}